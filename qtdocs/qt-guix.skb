;; -*- mode: scheme; eval: (skribilo-mode 1); geiser-scheme-implementation: guile; compile-command: "cd .. && guix environment --ad-hoc skribilo guile -- guix repl -- compile-docs.scm"  -*-

;; this should be compiled with the wrapper script compile-docs.scm
;; which wraps skribilo inside a guix repl to allow compile-time
;; access to guix and channel functions.

(use-modules (skribilo source lisp) ;; source language scheme
             (skribilo engine)
             (skribilo package web-book) ;; use web-book layout
             (guix packages) ;; package-name
             (gnu packages) ;; %package-module-path
             (guix discovery) ;; all-modules
             ((guix ui) #:hide (display-profile-content))  ;; warn-about-load-error
             (guix scripts describe) ;; display-profile-content
             (guix describe) ;; current-channels
             (guix channels) ;; channel->code
             (guix import print) ;; package->code
             (ice-9 pretty-print)
             (srfi srfi-9 gnu) ;; set-fields
             (srfi srfi-19)) ;; date->string, current-date

(define channel-code-str
  (with-output-to-string
    (λ () (pretty-print `(list ,@(map channel->code (current-channels)))))))

(define guix-channel
  (car (filter (λ (ch) (eq? (channel-name ch) 'guix)) (current-channels))))

(define (update-channel ch url branch)
  (set-fields ch
              ((channel-url) url)
              ((channel-branch) branch)
              ((channel-commit) #f)))

(define local-channel-str
  (with-output-to-string
    (λ () (pretty-print
           `(list ,(channel->code
                    (update-channel guix-channel
                                    "file:///home/my-username/git/qt-guix"
                                    "feature/FOO-123")))))))

(let ((html (find-engine 'html)))
  (if (engine? html)
      (begin
        ;; Customizing the HTML output...
        (engine-custom-set! html 'css "static/manual.css")
        (engine-custom-set! html 'charset "UTF-8"))))


(document :title [Quantile QT-Guix Documentation]
          :author #f
          :keywords '("Guix" "CI/CD" "Packages" "Build")
  
  ;; ----------------------------------------
  ;; ------------- LANDING PAGE -------------
  ;; ----------------------------------------
  (p [Document compilation date: ,(date->string (current-date))
,(linebreak 2)
This document will provide accompanying notes to the Quantile's
,(ref :url "https://github.com/quantiletechnologies/qt-guix" :text "qt-guix")
repository. This a fork of Guix containig a handful of enhancements we aim to ultimately
merge back into Guix proper, pending acceptance from the wider community.  It's very much a WIP for now!
,(linebreak 2)
Here is the channel snapshot used to generate the details in this document.])
  (frame :width 100.
         (prog :line #f
               (source :language scheme
                       channel-code-str)))

  ;; ------------------------------------
  ;; ------------- CHAPTERS -------------
  ;; ------------------------------------
  (chapter :title [Development Guidelines]
    (section :title [What to Clone]
      (p [The qt-guix repo can be cloned just like an internal repo using the following URL.
,(linebreak 2)
,(code "git@github.com:quantiletechnologies/qt-guix.git")
,(linebreak 2)
In order to be able to push to the repository you will to have your GPG key added to the Guix
Authorizations, and be granted write access to the repository.
]))
    (section :title [Mandatory Use of Feature Branches]
      (p [All work must be carried out in feature branches off the quantile branch.
Merging work to the the quantile branch will require a rebuild of Guix and must be done in
a controlled fashion.  Do not merge to quantile branch without explicit prior approval.])
      )
    (section :title [Testing Locally]
      (p [The easiest way to test a change is with a local
,(ref :url "https://guix.gnu.org/manual/en/guix.html#Channels" :text "channel") file, referencing
a local clone of qt-guix, using
,(ref :url "https://guix.gnu.org/manual/en/guix.html#Invoking-guix-time_002dmachine" :text "time-machine").
A bare-bones example channels file prepared for this purpose is given below, notice we've aligned the guix
channel to a local repo, a feature branch, and we've removed the commit id anchoring.])
      (frame :width 100.
             (prog :line #f
                   (source :language scheme
                           local-channel-str))))
    (section :title [Testing Using Remote Feature Branch]
      (p [Once you've satisfied yourself that your local clone tests OK, you can push your
,(underline "signed") changes to a remote feature branch.  You can then update your channel
file to test this either using time-machine as per above, or by adding a user-level channels file to
,(code "/home/my-username/.config/guix/channels.scm") and doing a ,(code "guix pull").]))
    (section :title [Merge in quantile Branch]
      (p [Do not merge using the Github merge tool - this will not sign your merge commit!
Please merge locally and make sure all commits both your own and any merges done on your
behalf by git are signed before pushing.  There is a
,(ref :url "https://github.com/quantiletechnologies/qt-guix/blob/43c1bbd8aa06ff1ae7d8940725c6b16d1b25f065/.pre-commit-config.yaml#L7" :text "pre-push")
hook in the repository that should be used to check all commits are authenticated.])
      ))
  (chapter :title [Synchronizing with Guix]
    (section :title [Synchronizing the Keyring Branch]
      (p [Before pulling in any changes from Guix you first must think about if these new changes
were signed by a new key.  If so then you should update the keyring branch first.  The keyring
branch should be additive however be well aware that a discrepancy between master and quantile
branches must be such that the keyring branch can authorized both branches at once.  Thus adding a
new key to keyring to satisfy a master ahead of quantile branch is fine.  If a key is removed from
keyring for some reason then do update the keyring branch until both master and quantile are in sync.
If the latest keyring branch contains both additions and removals this is potentially an issue and keyring
might not be able to authorize across 2 divergent branches such as master and quantile.  Think carefully
before proceeding with any change in these circumstances!])
      )
    (section :title [Synchronizing the Master Branch]
      (p [This is typically kept reasonably up-to date with Guix's own master branch.  Production systems
are not run off this branch, more it represents a staging branch for that we can test and verify
before incorporating changes into the quantile branch.  We ,(underline "never") commit our own changes to
this branch - it is always represents some perfect copy of Guix proper at some point in time.])
      )
    (section :title [Synchronizing the Quantile Branch]
      (p [This branch is our production version of Guix.  It contains some tested Guix baseline, merged
in from the master branch and any changes to the Guix code made in quantile and not yet patched into Guix
proper.  Changes to this branch should never occur without prior approval.  Upgrading it is the subject of
the next chapter.])))
  (chapter :title [Upgrading From Guix Baseline]
    (p [Quantile lags the true head of Guix, anchoring to a commit that is well tested against our internal
software, and then moving incrementally to a new commit baseline as required.  This section covers the process by
which we publish a new baseline candidate, test against it, and release it.  The details are general and apply
to all projects.  The specifics of signing-off each internal project are not covered here.])
    (section :title [Creating a Future Channel]
      (p [A ,(ref :url "https://guix.gnu.org/manual/en/guix.html#Channels" :text "channel") is nothing more than a
Git repo that contains package definitions.  A new channel file will be made available by the Guix release manager
- essentially this contains a new commit-id in the channel repo which represents some future state of the packages.
This can be used in place of the default ,(code [/etc/guix/channel.scm]) channel to create a local environment
representative of the proposed state of our Guix baseline.  This is done using the
,(ref :url "https://guix.gnu.org/manual/en/guix.html#Invoking-guix-time_002dmachine" :text "time-machine")
command.]))
    (section :title [Which Packages will be Upgraded?]
      (p [It can be useful to know given a channel and a project, which dependencies have changed.  There is a
,(ref :url "https://guix.gnu.org/manual/en/guix.html#Invoking-guix-repl" :text "guix repl") script which can do
this for you in ea-tools called ,(code [compare-package-versions.scm]).  It will list: any dependencies which have
changed, what the new highest version number is, and any alternative versions available in the channel.]))
    (section :title [Building and Installing Against a Future Channel]
      (p [Once we have a copy of the future channel, building my-project against it is as simple as:])
      (code "guix time-machine -C /path/to/my/copy/of/the/future/channel.scm -- build my-project")
      (p [If the build completes we can be sure that the source compiles and the unit tests pass - which is a
good indicator that the software is at least syntactically compatible.  However building alone is not enough,
it is also required to install the newly built my-project into a Guix profile, as some errors such as package clashes
only manifest themselves at install time:])
      (code "guix time-machine -C /path/to/my/copy/of/the/future/channel.scm -- install -p /path/to/my/test/profile my-project")
      (p [Note that if the previous build step is not done, the install will also take care of the build, however
you will get far less information on stdout using the install method, so it is recommended to build separately first.]))
    (section :title [Branch Substitution using Package Transformations]
      (p [If you are fortunate enough to have the current integration package of your project build and test under
the new baseline without any issues, then you don't need to read this section.  More realistically, when you try to
build or when we run our unit or regression tests we come across issues which warrant change not to the package,
but to the project code.  In an ideal world you would make changes that are backwards compatible with the current
Guix baseline such that the changes can be integrated immediately - this will substantially reduce the effort required
and risk undertaken during the release process itself - so it's strongly recommended you aim for this.  Alas, this is not
always possible - third party libraries occasionally introduce breaking changes and in these cases we need to create
a branch parallel to normal development (but kept in synchrony with it) which contains the breaking changes such that
the code is compatible with the future channel.  In order to test a branch against the future channel we use
,(ref "https://guix.gnu.org/manual/en/guix.html#Package-Transformation-Options" :text "Package Transformations"):])
      (code "guix time-machine -C /path/to/my/copy/of/the/future/channel.scm -- build my-project --with-branch=my-project=feature/FOO-123_my_branch")
      (p [As per the previous section, installation must be tested as well as building:])
      (code "guix time-machine -C /path/to/my/copy/of/the/future/channel.scm -- install --with-branch=my-project=feature/FOO-123_my_branch -p /path/to/my/test/profile my-project")
      (p [More complex transformations beyond just switching branch are possible, see the Guix Manual for details.]))
    (section :title [Changing Your Project Definition in the Quantile Channel]
      (p [It may be that as well as changing project code, changes are required to the package definitions for Quantile's
internal packages.  One example would be if the new baseline provides a package that we had previously built a custom version
of - in this case we should remove the custom definition and use the new standard Guix version.  This would usually be handled
by the channel file provided by the Guix Release Manager, where a release branch on ,(code [guix-packages]) could house
and required changes to our internal package structure.  Making changes to the Quantile Channel is beyond the scope
of this document, and should only ever be done by people on the guix-development team.  However one can clone the internal
channel and make changes locally ,(emph [providing]) these are *never* pushed back to the remote channel.  Local changes can
be tested by removing the reference to ,(code [guix-packages]) from a copy of the channel file and using the ,(code [-L])
switch to reference a local clone of the repo.  It is also possible to change the ,(code [guix-packages]) reference to point
to a local clone using ,(code [file:///path/to/my/local/clone]).  In the later case, you will need to commit your changes
to your ,(emph [local]) repo for them to be picked up.  Remember never push these local commits.  These are advanced techniques and
should only be attempted by people who have a clear understanding of the methods and the risks involved.]))
    (section :title [System Verification for your Project]
      (p [Each project maintains it's own System Verification Document which must be run twice during a normal release
cycle.])
      (enumerate
       (item [Before The Release - The System Verification Document should be executed and signed-off inside a
time-machine using the future channel.])
       (item [After The Release - The System Verification Document should be executed and signed-off in the standard
Guix production environment using the newly installed channel.]))
      (p [The release cannot proceed until all projects sign off the initial verification.  Any failure after the release
would be handled either by fixing forward, or rolling back if there is no alternative.]))
    (section :title [System Verification for any Dependent Projects]
      (p [The order of verification is important.  That is, projects at the stem of the dependency tree should be verified
before leaf projects - so that leaf project can be reasonably assured that all their dependencies are sane.  Also any change
to a stem project's dependencies must be reconciled against the leaf projects that depend on it.  For example if a new
dependency is introduced to a stem project, it is important to check that does not clash with a separately declared dependency
in a leaf project.  If such a change has taken place you can return all dependent projects using for ,(code [my-stem-project])
using ,(ref :url "https://guix.gnu.org/manual/en/guix.html#Invoking-guix-refresh" :text "guix refresh"):])
      (code "guix refresh -l my-stem-project")
      (p [There is also a ,(ref :url "https://guix.gnu.org/manual/en/guix.html#Invoking-guix-repl" :text "guix repl") script
available in ea-tools called ,(code [get-dependency-locations.scm]) to do the reverse - that is, given a package - what does it
depend on?  It can filter by Quantile custom packages as well as listing standard Guix packages.])))
  (chapter :title [Documenting Guix Packages]
    (section :title [Writing Documentation]
      (p [Documentation of our Guix patches that we aim to provide back to the Guix project are kept in the
qt-guix repo.  This allows for public referencing of the patches before submission to the Guix project.
Documentation of internal channels and processes not intended for upstream patching is kept entirely separate
from this.])
      (subsection :title [Skribilo]
        (p [We use ,(ref :url "https://www.nongnu.org/skribilo" :text "skribilo" ) to compile documentation.])))
    (section :title [Documentation Tools]
      (p [See Skribilo's website for a useful Emacs plugin for writing documentation in.  We also provide some yasnippet
templates for generating chapters, sections, etc.]))
    (section :title [Compiling Documentation]
      (p [In emacs you should just be able to ,(code "M-x compile") to generate the HTML.  Outside of Emacs the following
will work:])
      (code "guix environment --ad-hoc skribilo guile -- guix repl -- compile-docs.scm")))
  (chapter :title [A List of Current Enhancements]
    (p [The current quantile changes to Guix proper can be seen
,(ref :url "https://github.com/guix-mirror/guix/compare/master...quantiletechnologies:qt-guix:quantile" :text "here").])
    (section :title [,(ref :url "https://github.com/guix-mirror/guix/commit/9ec3fe1d3004406cce7dc101b47f1a9997f06e8f" :text "Optional Force Color when not TTY")]
      (p [When running Guix inside a system that automates the running of Guix commands rather than entering the commands
into the console as a user, it is still nice to have Color output from Guix which is recorded in our automation logs.
This allows this by introducing a new optional environment variable ,(code "GUIX_COLOR_OUTPUT") to control this setting.]))
    (section :title [,(ref :url "https://github.com/guix-mirror/guix/commit/473954dd92bbb84693b6fa3f007752eb53c804db" :text "Always Fetch Git References")]
      (p [This is a workaround of a ,(ref :url "https://github.com/libgit2/libgit2/issues/6183" :text "bug") in libgit2 which Guix
relies on.  The proper fix should be in libgit2 but this resolves the issue in Guix in the interim.  This issue is an optimization
in Guix that a fetch is not performed immediately after the clone of a source repo.  However, if we need to clone extra references
added to our git config, because we are building a PR branch created off an automatic merge for example - when using libgit2 then the
fetch is mandatory.  Even immediately after a clone, these references will not exist until a fetch or pull is performed.  This behavior
is divergent from the latest git command line tool which automatically fetches refs on the first clone.]))
    (section :title [,(ref :url "https://github.com/guix-mirror/guix/commit/49900405617fdf6a2e4ab6f4004306a2770221e0" :text "Printing git-checkout Package Sources")]
      (p [Currently the ,(code "source->code") function only supports sources that a are ,(code "origin") records.  When referencing
package source that have SSH based URLs it is necessary to use a ,(code "git-checkout") record instead.  However doing so
currently will result in a failure if the package is passed to ,(code "package->code").  This fixes the issue.])
      (frame :width 100.
             (prog :line #f
                   (source :language scheme
                           [(package
  (name "example")
  (version "123")
  (source
    (git-checkout
      (url "ssh://git@foo/foo/bar.git")
      (commit "12345abcd"))))]))))))
